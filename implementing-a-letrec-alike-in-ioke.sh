#!/bin/bash
export TITLE="Implementing a letrec alike in Ioke"
export TAGS="programming ioke code"
export CANONICAL="implementing-a-letrec-alike-in-ioke"
export TEXT=$(markdown -f nopants -f footnote << END
So, some time ago I tried to demonstrate the Parser Combinator approach to parsing to a friend, with a simple JSON parser in Ioke. This parser would be built in two layers; a generic <code class="nc">Parser</code> object, with some basic combinators, and a <code class="nc">JSONParser</code> object with additional parsers for JSON. The simple parser was easy enough; <code class="nf">lit</code>, <code class="nf">alt</code>, <code class="nf">seq</code>, <code class="nf">star</code>, <code class="nf">many1</code>, <code class="nf">wrapped</code> etc were easy to define. Things became interesting when, for the JSON parser, I had definitions for <code class="nf">list</code> and <code class="nf">dict</code> which were mutually recursive. Theoretically, the <code class="k">with</code> construct should enable this; as it turns out, it seems to only work when all of the mutually recursive functions do not depend on anything further up the chain of mimics, and even then not reliably. So, I let it rest.

Half a year later I took a short holiday, and as often happens decided that a spot of yak shaving was called for. What I wanted was something similar to <code class="k">letrec</code> in Scheme; this was complicated by potential activateability, and the idea that a value might be a result of the activation of its definition; for example, many of the parsers are defined by combinators taking parsers as arguments, returning new parsers. The parsers must act as inactivateable to be easily passed as arguments, but the initial definition of the parser may depend upon activateability to produce the actual parser value. The methods in the literature did not seem to handle this; they either seem to need function definitions to be totally declarative and references to cells to be completely late bound, or for simple lambda wrapping to work. So, after assuring myself that I wasn't ignoring the literature, I proceeded to write some code. In Ioke it is acceptable to make use of gratuitous mutation; so I took a decidedly kludgy approach and had the values wrap themselves in a macro which, when activated, queried the environment to see whether they should be inactivateable, and either fake inactivateability if so, or else proceed to replace the contents of their cell with the result of the invocation of the evaluation of their stashed quoted definition, and then activate themselves. The result, after many iterations, was basically like the various lambda wrapping methods, with an added heuristic to deal with activateability and an implementation of quote-invoke-replace-invoke I haven't seen anywhere else[^1]. There are still several ways that this fails to give true simultaneous assignment; notably while the created object will respond to the appropriate message invocation to return/activate cells, the cells will both look different to introspection and not show up in some parts of the MOP (ie <code class="k">cellNames</code>, <code class="k">cells</code>) until they have been activated for the first time at the top level; also, anything that requires strictness due to side effects or dependence on transitory external state during the definition will obviously not work as intended without extra work wrapping the dependent state and forcing the computation.

Anyhow, here is the code I came up with:

<div class="code"><pre><code><span class="nc">DefaultBehavior</span> <span class="nb">FlowControl</span> <span class="nv">letrec</span> <span class="o">=</span> <span class="nf">macro</span><span class="p">(</span>
  <span class="ni">newObject</span> <span class="o">=</span> <span class="p">@</span><span class="k">mimic</span> 
  <span class="n">call</span> <span class="n">arguments</span> <span class="n">each</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> 
    <span class="kr">if</span><span class="p">(</span><span class="n">arg</span> <span class="n">keyword?</span><span class="p">,</span>
        <span class="nb">Reflector</span> <span class="n">other:cell</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arg</span> <span class="n">name</span> <span class="k">asText</span> <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mf">-2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(&#39;&#39;(</span><span class="nf">method</span><span class="p">(</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="o">+</span><span class="ss">:b</span><span class="p">,</span>
          <span class="c">; Make inactivateable for the moment</span>
          <span class="kr">if</span><span class="p">(</span><span class="n">a</span> <span class="n">empty?</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="n">empty?</span><span class="p">,</span> <span class="kr">return</span> <span class="p">@@)</span>
          <span class="nb">Reflector</span> <span class="n">other:cell</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">&quot;</span><span class="p">#{\`(</span><span class="n">arg</span> <span class="n">name</span> <span class="k">asText</span> <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mf">-2</span><span class="p">])}</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;&#39;(\`(</span><span class="n">arg</span> <span class="n">next</span><span class="p">))</span> <span class="n">evaluateOn</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
          <span class="nb">Reflector</span> <span class="n">other:send</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">&quot;</span><span class="p">#{\`(</span><span class="n">arg</span> <span class="n">name</span> <span class="k">asText</span> <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mf">-2</span><span class="p">])}</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span> <span class="n">b</span><span class="p">)))</span> <span class="n">evaluateOn</span><span class="p">(</span><span class="n">self</span><span class="p">)),</span> 
        <span class="nb">Reflector</span> <span class="n">other:send</span><span class="p">(</span><span class="n">newObject</span><span class="p">,</span> <span class="n">arg</span><span class="p">)))</span>
  <span class="n">newObject</span><span class="p">)</span></code></pre></div>

I would be interested to hear if there is a more idiomatic or less problematic way to do this in Ioke.

[^1]: Yes, the literature is substantial. Yes, I probably missed something. No, this is different from the various nil-placeholder-quote-replace implementations out there; even in languages with generalised places, the implementations seemed to set a context where there were all the correctly named places initialised to nil, then bind each defun to the appropriate place in turn, or else have the wrapped lambda form persist rather than removing itself. On the gripping hand, Ioke is more like a Smalltalk than a Lisp, so what I did might just be a simple mash together of these two Lispy idioms to a single Smalltalk-ish idiom, which may be better served by an authentically Smalltalky idiom like <code><span class="v">self</span> <span class="k">become!</span><span class="op">(</span>evaluated\_stashed\_value<span class="op">)</span></code>.
END
)
